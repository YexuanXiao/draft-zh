%!TEX root = std.tex
\rSec0[lex]{词法约定}

\gramSec[gram.lex]{词法约定}

\indextext{lexical conventions|see{约定, 词法}}
\indextext{translation!separate|see{编译, 独立}}
\indextext{separate translation|see{编译, 独立}}
\indextext{separate compilation|see{编译, 独立}}
\indextext{phases of translation|see{翻译, 阶段}}
\indextext{source file character|see{字符, 源文件}}
\indextext{alternative token|see{标记, 替代}}
\indextext{digraph|see{标记, 替代}}
\indextext{integer literal|see{字面量, 整数}}
\indextext{character literal|see{字面量, 字符}}
\indextext{floating-point literal|see{字面量, 浮点数}}
\indextext{string literal|see{字面量, 字符串}}
\indextext{boolean literal|see{字面量, 布尔}}
\indextext{pointer literal|see{字面量, 指针}}
\indextext{user-defined literal|see{字面量, 用户定义}}
\indextext{file, source|see{源文件}}
\indextext{null character|see{字符, 空}}
\indextext{null wide character|see{宽字符, 空}}

\rSec1[lex.separate]{单独翻译}

\pnum
\indextext{conventions!lexical|(}%
\indextext{compilation!separate|(}%
程序文本保存在称为\defnx{源文件}{source file}的单元中。
一个源文件连同所有通过预处理指令\tcode{\#include}包含的标头\iref{headers}和源文件\iref{cpp.include}，
减去被任何条件包含\iref{cpp.cond}预处理指令跳过的源行，
并受任何条件支持指令\iref{cpp.pre}和编译指示\iref{cpp.pragma}的实现定义行为修改后，
称为一个\defnadj{预处理}{翻译单元}。
\begin{note}
\Cpp{} 程序不必一次性全部翻译。
翻译单元可单独翻译，随后链接生成可执行程序\iref{basic.link}。
\end{note}
\indextext{compilation!separate|)}

\rSec1[lex.phases]{翻译阶段}%

\pnum
\indextext{translation!phases|(}%
翻译语法规则之间的优先顺序由以下阶段规定。
\begin{footnote}
实现的行为表现得如同这些独立阶段依次发生，尽管在实践中可将不同阶段合并。
\end{footnote}

\begin{enumerate}
\item
\indextext{character!source file}%
实现应支持输入文件为 UTF-8 代码单元序列（UTF-8 文件）。
它也可支持
一个 \impldef{supported input files} 的其他种类输入文件集合，且
若如此，输入文件种类以
\impldef{determination of kind of input file} 方式确定，
该方式包含将输入文件指定为 UTF-8 文件的手段，
而与其内容无关。
\begin{note}
换言之，
仅识别 \unicode{feff}{字节顺序标记} 并不足够。
\end{note}
若输入文件被确定为 UTF-8 文件，
则它应是良构的 UTF-8 代码单元序列，并被解码产生一个 Unicode
\begin{footnote}
Unicode\textregistered\ 是 Unicode, Inc. 的注册商标。
本信息仅为本文档用户提供便利，不构成 ISO 或 IEC 对该产品的认可。
\end{footnote}
标量值序列。
随后通过将每个 Unicode 标量值
映射到对应的翻译字符集元素，形成
翻译字符集元素序列\iref{lex.charset}。
在所得序列中，
输入序列中由
\unicode{000d}{回车} 紧接 \unicode{000a}{换行} 构成的每一对字符，
以及每个
未紧接 \unicode{000a}{换行} 的 \unicode{000d}{回车}，
均被替换为单个新行字符。

对于实现支持的任何其他种类输入文件，
字符以
\impldef{mapping input file characters to translation character set} 方式
被映射到翻译字符集元素序列，
并将行结束指示符表示为新行字符。

\item
\indextext{line splicing}%
若第一个翻译字符为 \unicode{feff}{字节顺序标记}，
则将其删除。
每个由反斜杠字符 (\textbackslash)
紧接零个或多个非新行的空白字符再紧接新行字符构成的序列被删除，从而拼接
物理源行以形成 \defnx{逻辑源行}{source line!logical}。只有任意物理源行上的
最后一个反斜杠才有资格参与此类拼接。
\begin{note}
行拼接可形成
\grammarterm{通用字符名}\iref{lex.charset}。
\end{note}
非空且在拼接后不以新行字符结尾的
源文件应被视为已在文件末尾追加了一个额外的新行字符。

\item 源文件被分解为预处理
记号\iref{lex.pptoken} 以及空白字符序列
（含注释）。源文件不得以部分
预处理记号或部分注释结束。
\begin{footnote}
部分预处理
记号会在源文件
以多字符记号的首部结尾时出现，该记号需要终止字符序列，例如缺少闭合 \tcode{"}
或 \tcode{>} 的 \grammarterm{头文件名}。
部分注释会在源文件
以未闭合的 \tcode{/*} 注释结尾时出现。
\end{footnote}
每个注释\iref{lex.comment} 被替换为一个 \unicode{0020}{空格} 字符。新行字符
予以保留。除新行外的每个非空空白字符序列
是保留还是被替换为一个 \unicode{0020}{空格} 字符
未作规定。
当从源文件读取字符
以形成下一个预处理记号时
（即，不作为注释或其他空白的一部分被消耗），
除非正在匹配
\grammarterm{c-char-sequence}、
\grammarterm{s-char-sequence}、
\grammarterm{r-char-sequence}、
\grammarterm{h-char-sequence} 或
\grammarterm{q-char-sequence}，
否则识别 \grammarterm{通用字符名}\iref{lex.universal.char} 并将其
替换为翻译字符集\iref{lex.charset} 的对应元素。
将源文件
字符划分为预处理记号的过程依赖于上下文。
\begin{example}
参见 \tcode{\#include} 预处理
指令\iref{lex.header,cpp.include} 中对 \tcode{<} 的处理。
\end{example}

\item 源文件被分析为 \grammarterm{预处理文件}\iref{cpp.pre}。
执行预处理指令\iref{cpp}，展开
宏调用\iref{cpp.replace}，并执行 \tcode{_Pragma} 一元运算符表达式\iref{cpp.pragma.op}。
\tcode{\#include} 预处理指令\iref{cpp.include} 将使指定的头文件或
源文件从阶段 1 至阶段 4 被递归处理。
随后所有预处理指令被删除。
分隔预处理记号的空白字符不再具有意义。

\item
对于两个或更多相邻 \grammarterm{string-literal} 预处理记号构成的序列，
按 \ref{lex.string} 规定确定共同 \grammarterm{encoding-prefix}。
随后每个此类 \grammarterm{string-literal} 预处理记号被视为具有
该共同 \grammarterm{encoding-prefix}。

\item
\indextext{concatenation!string}%
相邻 \grammarterm{string-literal} 预处理记号被连接\iref{lex.string}。

\item
每个预处理记号被转换为记号\iref{lex.token}。
所得记号构成一个 \defn{翻译单元} 并被
语法及语义地分析为 \grammarterm{translation-unit}\iref{basic.link} 并
被翻译。
\begin{note}
在分析与翻译记号的过程中，偶尔
会导致一个记号被其他记号序列替换\iref{temp.names}。
\end{note}
\impldef{whether the sources for
module units and header units
on which the current translation unit has an interface
dependency are required to be available during translation}
规定
当前翻译单元对其有接口
依赖\iref{module.unit,module.import} 的模块单元与头文件单元
的源代码
是否必须在翻译期间可用。
\begin{note}
源文件、翻译
单元及已翻译的翻译单元不必以文件形式存储，这些实体与任何外部表示之间
也不必存在一一对应关系。
本描述仅为概念性，并未规定任何具体实现。
\end{note}
\begin{note}
先前翻译的翻译单元可单独保存或置于库中。
程序的各个翻译单元通过（例如）调用
具有外部或模块链接的函数、
操作具有外部或模块链接的变量，或操作数据文件
进行通信\iref{basic.link}。
\end{note}

在分析与翻译构成翻译单元的记号期间，
执行所需的实例化。
\begin{note}
这可包含已被显式
请求的实例化\iref{temp.explicit}。
\end{note}

可执行实例化的上下文
由各自的实例化点\iref{temp.point} 确定。

\begin{note}
本文档的其他要求可进一步限制
可执行实例化的上下文。
例如，constexpr 函数模板特化
可能在翻译单元末尾有实例化点，
但其在某些常量表达式中的使用可能要求
在更早的点进行实例化\iref{temp.inst}。
\end{note}

每次实例化产生新的程序构造。
若任何实例化失败，则程序为病式。

在分析与翻译记号期间，
某些表达式被求值\iref{expr.const}。
出现在程序点 $P$ 的构造
在上下文中进行分析，其中
对表达式 $E$ 作为完整表达式求值的每个副作用完成，当且仅当
\begin{itemize}
\item
$E$ 是对应于
\grammarterm{consteval-block-declaration}\iref{dcl.pre} 的表达式，且
\item
该 \grammarterm{consteval-block-declaration} 或
其实例化来源的模板定义
可从\iref{module.reach}
\begin{itemize}
\item
$P$ 到达，或
\item
紧跟 $P$ 所在的完整类上下文中
最外层类\iref{class.mem.general} 的 \grammarterm{class-specifier} 之后的位置。
\end{itemize}
\end{itemize}
\begin{example}
\begin{codeblock}
class S {
  class Incomplete;

  class Inner {
    void fn() {
      /* @$p_1$@ */ Incomplete i;    // OK
    }
  }; /* @$p_2$@ */

  consteval {
    define_aggregate(^^Incomplete, {});
  }
}; /* @$p_3$@ */
\end{codeblock}
$p_1$ 处的构造在
对 \tcode{define_aggregate} 调用的副作用已求值的上下文中进行分析，因为
\begin{itemize}
\item
$E$ 是对应于 consteval 块的表达式，且
\item
$p_1$ 位于 \tcode{S} 的完整类上下文中，且
该 consteval 块可从 $p_3$ 到达。
\end{itemize}
\end{example}

\item
\indextext{linking}%
合并已翻译的翻译单元，并
解析所有外部实体引用。链接库
组件以满足对当前翻译单元中未定义实体的外部引用。
所有此类翻译器输出被收集为程序映像，其中包含
在其执行环境中执行所需的信息。%
\indextext{translation!phases|)}
\end{enumerate}

\rSec1[lex.char]{字符}%

\rSec2[lex.charset]{字符集}

\pnum
\indextext{character set|(}%
\defnadj{翻译}{字符集}由以下元素组成：
\begin{itemize}
\item
每一个根据 Unicode 标准在 Unicode 码点空间内分配有码点的抽象字符，以及
\item
为每一个未分配给抽象字符的 Unicode 标量值分配的独立字符。
\end{itemize}
\begin{note}
Unicode 码点是
取值范围为 $[0, \mathrm{10FFFF}]$（十六进制）的整数。
代理码点是
取值范围为 $[\mathrm{D800}, \mathrm{DFFF}]$（十六进制）的值。
Unicode 标量值指任何非代理码点的码点。
\end{note}

\pnum
\defnadj{基本}{字符集}是翻译字符集的一个子集，
由 99 个字符组成，如 \tref{lex.charset.basic} 所述。
\begin{note}
仅提供 Unicode 短名称作为标识字符的手段；
数值在此上下文中没有其他含义。
\end{note}

\begin{floattable}{基本字符集}{lex.charset.basic}{lll}
\topline
\lhdrx{2}{字符} & \rhdr{字形} \\ \capsep
\ucode{0009} & \uname{character tabulation} & \\
\ucode{000b} & \uname{line tabulation} & \\
\ucode{000c} & \uname{form feed} & \\
\ucode{0020} & \uname{space} & \\
\ucode{000a} & \uname{line feed} & 换行 \\
\ucode{0021} & \uname{exclamation mark} & \tcode{!} \\
\ucode{0022} & \uname{quotation mark} & \tcode{"} \\
\ucode{0023} & \uname{number sign} & \tcode{\#} \\
\ucode{0024} & \uname{dollar sign} & \tcode{\$} \\
\ucode{0025} & \uname{percent sign} & \tcode{\%} \\
\ucode{0026} & \uname{ampersand}  & \tcode{\&} \\
\ucode{0027} & \uname{apostrophe} & \tcode{'} \\
\ucode{0028} & \uname{left parenthesis} & \tcode{(} \\
\ucode{0029} & \uname{right parenthesis} & \tcode{)} \\
\ucode{002a} & \uname{asterisk} & \tcode{*} \\
\ucode{002b} & \uname{plus sign} & \tcode{+} \\
\ucode{002c} & \uname{comma} & \tcode{,} \\
\ucode{002d} & \uname{hyphen-minus} & \tcode{-} \\
\ucode{002e} & \uname{full stop} & \tcode{.} \\
\ucode{002f} & \uname{solidus} & \tcode{/} \\
\ucode{0030} .. \ucode{0039} & \uname{digit zero .. nine} & \tcode{0 1 2 3 4 5 6 7 8 9} \\
\ucode{003a} & \uname{colon} & \tcode{:} \\
\ucode{003b} & \uname{semicolon} & \tcode{;} \\
\ucode{003c} & \uname{less-than sign} & \tcode{<} \\
\ucode{003d} & \uname{equals sign} & \tcode{=} \\
\ucode{003e} & \uname{greater-than sign} & \tcode{>} \\
\ucode{003f} & \uname{question mark} & \tcode{?} \\
\ucode{0040} & \uname{commercial at} & \tcode{@} \\
\ucode{0041} .. \ucode{005a} & \uname{latin capital letter a .. z} & \tcode{A B C D E F G H I J K L M} \\
 & & \tcode{N O P Q R S T U V W X Y Z} \\
\ucode{005b} & \uname{left square bracket} & \tcode{[} \\
\ucode{005c} & \uname{reverse solidus} & \tcode{\textbackslash} \\
\ucode{005d} & \uname{right square bracket} & \tcode{]} \\
\ucode{005e} & \uname{circumflex accent} & \tcode{\caret} \\
\ucode{005f} & \uname{low line} & \tcode{_} \\
\ucode{0060} & \uname{grave accent} & \tcode{\`} \\
\ucode{0061} .. \ucode{007a} & \uname{latin small letter a .. z} & \tcode{a b c d e f g h i j k l m} \\
 & & \tcode{n o p q r s t u v w x y z} \\
\ucode{007b} & \uname{left curly bracket} & \tcode{\{} \\
\ucode{007c} & \uname{vertical line} & \tcode{|} \\
\ucode{007d} & \uname{right curly bracket} & \tcode{\}} \\
\ucode{007e} & \uname{tilde} & \tcode{\textasciitilde} \\
\end{floattable}

\pnum
\defnadj{基本字面}{字符集}由
基本字符集中的所有字符，
加上 \tref{lex.charset.literal} 中指定的控制字符组成。

\begin{floattable}{基本字面字符集中的附加控制字符}{lex.charset.literal}{ll}
\topline
\ohdrx{2}{字符} \\ \capsep
\ucode{0000} & \uname{null} \\
\ucode{0007} & \uname{alert} \\
\ucode{0008} & \uname{backspace} \\
\ucode{000d} & \uname{carriage return} \\
\end{floattable}

\pnum
\defn{编码单元}是
字符类型\iref{basic.fundamental}的整数值。
在 \grammarterm{字符字面量}（多字符或不可编码字符字面量除外）中，
或在 \grammarterm{字符串字面量} 中的字符被编码为
一个或多个编码单元的序列，由
\grammarterm{编码前缀}\iref{lex.ccon,lex.string} 确定；
这称为相应的 \defnadj{字面}{编码}。
\defnadj{普通字面}{编码}是
应用于普通字符或字符串字面量的编码。
\defnadj{宽字面}{编码}是
应用于宽字符或字符串字面量的编码。

\pnum
一个字面编码或
某个执行字符集\iref{character.seq}的区域特定编码
将基本字面字符集中的每个元素编码为
一个具有非负值的单个编码单元，
该编码单元与任何其他此类元素的编码单元不同。
\begin{note}
不在基本字面字符集中的字符
可以用多个编码单元编码；
这种编码单元的值可以与
基本字面字符集元素的编码单元值相同。
\end{note}
\indextext{character!null}%
\indextext{wide-character!null}%
\unicode{0000}{null} 字符被编码为值 \tcode{0}。
翻译字符集中的任何其他元素
都不会用值为 \tcode{0} 的编码单元编码。
\tcode{0}（\ucode{0030}）之后的每个十进制数字字符的编码单元值
应比前一个数字的值大 1。
普通和宽字面编码的其他方面由
\impldef{普通和宽字面编码} 实现定义。
\indextext{UTF-8}%
\indextext{UTF-16}%
\indextext{UTF-32}%
对于 UTF-8、UTF-16 或 UTF-32 字面量，
实现应按照 Unicode 标准
为相应的 Unicode 编码形式编码
与翻译字符集每个字符对应的 Unicode 标量值。
\indextext{character set|)}

\rSec2[lex.universal.char]{通用字符名}

\begin{bnf}
\nontermdef{n-char}\br
     除\unicode{007d}{右花括号}或换行字符之外的翻译字符集的任意成员
\end{bnf}

\begin{bnf}
\nontermdef{n-char-sequence}\br
   n-char \opt{n-char-sequence}
\end{bnf}

\begin{bnf}
\nontermdef{named-universal-character}\br
    \terminal{\textbackslash N\{} n-char-sequence \terminal{\}}
\end{bnf}

\begin{bnf}
\nontermdef{hex-quad}\br
    十六进制数字 十六进制数字 十六进制数字 十六进制数字
\end{bnf}

\begin{bnf}
\nontermdef{simple-hexadecimal-digit-sequence}\br
    十六进制数字 \opt{simple-hexadecimal-digit-sequence}
\end{bnf}

\begin{bnf}
\nontermdef{universal-character-name}\br
    \terminal{\textbackslash u} hex-quad\br
    \terminal{\textbackslash U} hex-quad hex-quad\br
    \terminal{\textbackslash u\{} simple-hexadecimal-digit-sequence \terminal{\}}\br
    named-universal-character
\end{bnf}

\pnum
\grammarterm{universal-character-name}构造提供了一种仅使用基础字符集来命名翻译字符集中任意元素的方法。
若在\grammarterm{character-literal}或\grammarterm{string-literal}的
\grammarterm{c-char-sequence}、\grammarterm{s-char-sequence}或\grammarterm{r-char-sequence}之外
（包括任一情况中的\grammarterm{user-defined-literal}内）
的\grammarterm{universal-character-name}对应一个控制字符或基础字符集中的字符，
则程序非良构。
\begin{note}
在\grammarterm{r-char-sequence}\iref{lex.string}中形似\grammarterm{universal-character-name}的字符序列不构成\grammarterm{universal-character-name}。
\end{note}

\pnum
形式为\tcode{\textbackslash u} \grammarterm{hex-quad}、
\tcode{\textbackslash U} \grammarterm{hex-quad} \grammarterm{hex-quad}或
\tcode{\textbackslash u\{\grammarterm{simple-hexadecimal-digit-sequence}\}}
的\grammarterm{universal-character-name}，
指代翻译字符集中Unicode标量值等于
该\grammarterm{universal-character-name}中\grammarterm{hexadecimal-digit}序列
所表示的十六进制数的字符。
若该数不是Unicode标量值，则程序非良构。

\pnum
如果一个\grammarterm{universal-character-name}是\grammarterm{named-universal-character}，
则当\grammarterm{n-char-sequence}等于其字符名称或等于其类型为“control”、“correction”或“alternate”的字符名称别名时，
它指代Unicode标准（第4.8章名称）中的相应字符；
否则，程序非良构。
\begin{note}
这些别名列于Unicode字符数据库的\tcode{NameAliases.txt}中。
这些名称或别名均无前导或尾随空格。
\end{note}

\rSec1[lex.comment]{注释}

\pnum
\indextext{注释|(}%
\indextext{注释!\tcode{/*} \tcode{*/}}%
\indextext{注释!\tcode{//}}%
字符\tcode{/*}开始一个注释，该注释由字符\tcode{*/}终止。这些注释不嵌套。
\indextext{注释!\tcode{//}}%
字符\tcode{//}开始一个注释，该注释在下一个换行字符之前立即终止。
\begin{note}
注释字符\tcode{//}、\tcode{/*}和\tcode{*/}在\tcode{//}注释中没有特殊含义，并与其他字符同样处理。类似地，注释字符\tcode{//}和\tcode{/*}在\tcode{/*}注释中也没有特殊含义。
\end{note}
\indextext{注释|)}

\rSec1[lex.pptoken]{预处理记号}

\indextext{token!preprocessing|(}%
\begin{bnf}
\nontermdef{preprocessing-token}\br
    header-name\br
    import-keyword\br
    module-keyword\br
    export-keyword\br
    identifier\br
    pp-number\br
    character-literal\br
    user-defined-character-literal\br
    string-literal\br
    user-defined-string-literal\br
    preprocessing-op-or-punc\br
    \textnormal{每个不能成为上述任何一类的非空白字符}
\end{bnf}

\pnum
预处理记号是在翻译阶段3到6中语言的最小词汇元素。
本文档中，字形用于标识基本字符集的元素\iref{lex.charset}。
预处理记号的类别有：头文件名、
由预处理 \tcode{import} 和 \tcode{module} 指令产生的占位记号
（\grammarterm{import-keyword}、\grammarterm{module-keyword} 和 \grammarterm{export-keyword}）、
标识符、预处理数字、字符字面量（包括用户定义字符
字面量）、字符串字面量（包括用户定义字符串字面量）、预处理
运算符和标点、以及按词汇不匹配其他预处理记号类别
的单个非空白字符。
如果 \unicode{0027}{撇号}、\unicode{0022}{引号}、
或任何不在基本字符集中的字符
匹配最后这个类别，那么程序是非良构的。
预处理记号可以用
\indextext{whitespace}%
空白分隔；
\indextext{comment}%
空白包括注释\iref{lex.comment} 或空白字符
（\unicode{0020}{空格}、
\unicode{0009}{字符制表符}、
换行、
\unicode{000b}{行制表符} 和
\unicode{000c}{换页符}），或两者皆有。
如 \ref{cpp} 所述，在翻译阶段4中的某些
情况下，空白（或其缺失）不仅充当预处理记号分隔符。空白
仅作为头文件名的一部分，或
在字符字面量或字符串字面量的引号字符之间，
才能出现在预处理记号内。

\pnum
每个转换为记号\iref{lex.token} 的预处理记号
应当具有关键词、标识符、字面量
或运算符或标点的词汇形式。

\pnum
\indexgrammar{\idxgram{import-keyword}}%
\indexgrammar{\idxgram{module-keyword}}%
\indexgrammar{\idxgram{export-keyword}}%
\grammarterm{import-keyword} 是通过
处理 \keyword{import} 指令\iref{cpp.import} 而产生的，
\grammarterm{module-keyword} 是通过
预处理 \keyword{module} 指令\iref{cpp.module} 而产生的，而
\grammarterm{export-keyword} 是通过
预处理前两个指令之一而产生的。
\begin{note}
它们都没有任何可观察的拼写。
\end{note}

\pnum
如果输入流已经解析为预处理记号直到某个
给定字符：
\begin{itemize}
\item
\indextext{literal!string!raw}%
如果下一个字符开始一个可能是原始字符串字面量
前缀和起始双引号的字符序列，如 \tcode{R"}，那么下一个预处理
记号应当是一个原始字符串字面量。在原始字符串的起始和终止
双引号字符之间，阶段2（行拼接）执行的任何变换都被还原；此还原
应当应用于识别任何 \grammarterm{d-char}、\grammarterm{r-char} 或定界
括号之前。该原始字符串字面量定义为匹配原始字符串模式的最短字符序列
\begin{ncbnf}
\opt{encoding-prefix} \terminal{R} raw-string
\end{ncbnf}

\item 否则，如果接下来的三个字符是 \tcode{<::} 且随后的字符
既不是 \tcode{:} 也不是 \tcode{>}，那么 \tcode{<} 被单独视为一个预处理记号，而不是
替代记号 \tcode{<:} 的第一个字符。

\item
否则，如果接下来的三个字符是 \tcode{[::} 且
随后的字符不是 \tcode{:}，或者
如果接下来的三个字符是 \tcode{[:>}，
那么 \tcode{[} 被单独视为一个预处理记号，而不是
预处理记号 \tcode{[:} 的第一个字符。
\begin{note}
记号 \tcode{[:} 和 \tcode{:]} 不能由双字符组组合而成。
\end{note}

\item 否则，
下一个预处理记号是
可能构成预处理记号的最长字符序列，即使那样
会导致进一步的词汇分析失败，
除了：
\begin{itemize}
\item
当一个 \grammarterm{header-name} 记号可以形成时，
绝不会形成一个 \grammarterm{string-literal} 记号，且
\item
一个 \grammarterm{header-name}\iref{lex.header} 仅在
\begin{itemize}
\item
紧接在 \tcode{include}、\tcode{embed} 或 \tcode{import} 预处理记号之后，分别在
\tcode{\#include}\iref{cpp.include}、\tcode{\#embed}\iref{cpp.embed} 或
\tcode{import}\iref{cpp.import} 指令中，或
\item
紧接在预处理记号序列 \xname{has_include}
或 \xname{has_embed} 后紧接着 \tcode{(}
在 \tcode{\#if}、\tcode{\#elif} 或 \tcode{\#embed} 指令中\iref{cpp.cond,cpp.embed}。
\end{itemize}
\end{itemize}
\end{itemize}

\pnum
\begin{example}
\begin{codeblock}
#define R "x"
const char* s = R"y";           // 非良构的原始字符串，不是 \tcode{"x" "y"}
\end{codeblock}
\end{example}

\pnum
\begin{example}
程序片段 \tcode{0xe+foo} 被解析为一个
预处理数字记号（它不是有效的
\grammarterm{integer-literal} 或 \grammarterm{floating-point-literal} 记号），
即使作为三个预处理记号
\tcode{0xe}、\tcode{+} 和 \tcode{foo} 解析可能产生一个有效的表达式（例如，
如果 \tcode{foo} 是定义为 \tcode{1} 的宏）。类似地，
程序片段 \tcode{1E1} 被解析为一个预处理数字（它是
有效的 \grammarterm{floating-point-literal} 记号），
无论 \tcode{E} 是否是宏名。
\end{example}

\pnum
\begin{example}
程序片段 \tcode{x+++++y} 被解析为 \tcode{x
++ ++ + y}，如果 \tcode{x} 和 \tcode{y} 具有整数类型，
这违反了增量运算符的约束，即使解析为
\tcode{x ++ + ++ y} 可以产生正确的表达式。
\end{example}
\indextext{token!preprocessing|)}

\rSec1[lex.header]{头文件名}

\indextext{header!name|(}%
\begin{bnf}
\microtypesetup{protrusion=false}
\nontermdef{header-name}\br
    \terminal{<} h-char-sequence \terminal{>}\br
    \terminal{"} q-char-sequence \terminal{"}
\end{bnf}

\begin{bnf}
\nontermdef{h-char-sequence}\br
    h-char \opt{h-char-sequence}
\end{bnf}

\begin{bnf}
\nontermdef{h-char}\br
    \textnormal{翻译字符集的任意成员，除换行符和\unicode{003e}{大于号}}
\end{bnf}

\begin{bnf}
\nontermdef{q-char-sequence}\br
    q-char \opt{q-char-sequence}
\end{bnf}

\begin{bnf}
\nontermdef{q-char}\br
    \textnormal{翻译字符集的任意成员，除换行符和\unicode{0022}{引号}}
\end{bnf}

\pnum
两种形式的\grammarterm{header-name}{s}的序列会以\impldef{映射头文件名到头文件或外部源文件}的方式映射到头文件或外部源文件名，如\ref{cpp.include}所述。
\begin{note}
头名字预处理记号仅出现于
\tcode{\#include}预处理指令内、
\tcode{__has_include}预处理表达式中，或
在\tcode{import}记号某些出现之后
（见\ref{lex.pptoken}）。
\end{note}

\pnum
字符\tcode{'}或\tcode{\textbackslash}之一，或字符序列\tcode{/*}或\tcode{//}之一，在\grammarterm{q-char-sequence}或\grammarterm{h-char-sequence}中的出现是条件性支持的，具有\impldef{字符\tcode{'}, \tcode{\textbackslash}, \tcode{/*}, 或 \tcode{//}在\grammarterm{q-char-sequence}或\grammarterm{h-char-sequence}中的含义}语义，字符\tcode{"}在\grammarterm{h-char-sequence}中的出现也是如此。
\begin{note}
因此，类似于转义序列的字符序列可能导致错误，被解释为对应转义序列的字符，或具有完全不同的含义，取决于实现。
\end{note}
\indextext{header!name|)}

\rSec1[lex.ppnumber]{预处理数字}

\indextext{number!preprocessing|(}%
\begin{bnf}
\nontermdef{pp-number}\br
    digit\br
    \terminal{.} digit\br
    pp-number identifier-continue\br
    pp-number \terminal{'} digit\br
    pp-number \terminal{'} nondigit\br
    pp-number \terminal{e} sign\br
    pp-number \terminal{E} sign\br
    pp-number \terminal{p} sign\br
    pp-number \terminal{P} sign\br
    pp-number \terminal{.}
\end{bnf}

\pnum
预处理数字的词法记号包含所有
\grammarterm{integer-literal} 记号\iref{lex.icon}
以及所有 \grammarterm{floating-point-literal} 记号\iref{lex.fcon}。

\pnum
预处理数字不具有类型和值；唯有在经过成功转换变为
\grammarterm{integer-literal} 记号或 \grammarterm{floating-point-literal} 记号后，它才获得对应的类型和值。%
\indextext{number!preprocessing|)}

\rSec1[lex.operators]{运算符与标点}

\pnum
\indextext{operator|(}%
\indextext{punctuator|(}%
\Cpp{} 程序的词法表示包含若干在预处理器语法中使用或被转换为运算符及标点记号的预处理记号：

\begin{bnf}
\nontermdef{preprocessing-op-or-punc}\br
    preprocessing-operator\br
    operator-or-punctuator
\end{bnf}

\begin{bnf}
%% 编者注：字符凸出会导致各种运算符错位。
\microtypesetup{protrusion=false}
\nontermdef{preprocessing-operator} \textnormal{其中之一}\br
    \terminal{\# \ \ \ \ \ \ \ \#\# \ \ \ \ \ \ \%: \ \ \ \ \ \ \%:\%:}
\end{bnf}

\begin{bnf}
\microtypesetup{protrusion=false}
\nontermdef{operator-or-punctuator} \textnormal{其中之一}\br
    \terminal{\{ \ \ \ \ \ \ \ \} \ \ \ \ \ \ \ [ \ \ \ \ \ \ \ ] \ \ \ \ \ \ \ ( \ \ \ \ \ \ \ ) \ \ \ \ \ \ \ [: \ \ \ \ \ \ :]}\br
    \terminal{<\% \ \ \ \ \ \ \%> \ \ \ \ \ \ <: \ \ \ \ \ \ :> \ \ \ \ \ \ ; \ \ \ \ \ \ \ : \ \ \ \ \ \ \ ...}\br
    \terminal{? \ \ \ \ \ \ \ :: \ \ \ \ \ \ . \ \ \ \ \ \ \ .* \ \ \ \ \ \ -> \ \ \ \ \ \ ->* \ \ \ \ \ \ \caret{}\caret{} \ \ \ \ \ \ \~}\br
    \terminal{! \ \ \ \ \ \ \ + \ \ \ \ \ \ \ - \ \ \ \ \ \ \ * \ \ \ \ \ \ \ / \ \ \ \ \ \ \ \% \ \ \ \ \ \ \ \caret{} \ \ \ \ \ \ \ \& \ \ \ \ \ \ \ |}\br
    \terminal{= \ \ \ \ \ \ \ += \ \ \ \ \ \ -= \ \ \ \ \ \ *= \ \ \ \ \ \ /= \ \ \ \ \ \ \%= \ \ \ \ \ \ \caret{}= \ \ \ \ \ \ \&= \ \ \ \ \ \ |=}\br
    \terminal{== \ \ \ \ \ \ != \ \ \ \ \ \ < \ \ \ \ \ \ \ > \ \ \ \ \ \ \ <= \ \ \ \ \ \ >= \ \ \ \ \ \ <=> \ \ \ \ \ \&\& \ \ \ \ \ \ ||}\br
    \terminal{<< \ \ \ \ \ \ >> \ \ \ \ \ \ <<= \ \ \ \ \ >>= \ \ \ \ \ ++ \ \ \ \ \ \ -- \ \ \ \ \ \ ,}\br
    \terminal{\keyword{and} \ \ \ \ \ \keyword{or} \ \ \ \ \ \ \keyword{xor} \ \ \ \ \ \keyword{not} \ \ \ \ \ \keyword{bitand} \ \ \keyword{bitor} \ \ \ \keyword{compl}}\br
    \terminal{\keyword{and_eq} \ \ \keyword{or_eq} \ \ \ \keyword{xor_eq} \ \ \keyword{not_eq}}
\end{bnf}

每个 \grammarterm{operator-or-punctuator} 在翻译阶段 7\iref{lex.phases} 被转换为单个记号。%
\indextext{punctuator|)}%
\indextext{operator|)}

\rSec1[lex.digraph]{替代记号}

\pnum
\indextext{token!alternative|(}%
为某些运算符和标点提供替代记号表示。
\begin{footnote}
\indextext{digraph}%
这些包括“双字符组”及额外的保留字。术语“双字符组”（由两个字符组成的记号）并不完全准确，因为一个替代\grammarterm{预处理记号}是
\tcode{\%:\%:}，当然也存在多个由两个字符构成的主要记号。尽管如此，那些并非词法关键字的替代记号仍被俗称为“双字符组”。
\end{footnote}

\pnum
在语言的任何方面，每个替代记号均与其对应的主要记号行为一致，唯拼写不同。
\begin{footnote}
因此，\tcode{[} 与 \tcode{<:} 的“字符串化”值\iref{cpp.stringize}将保持各自拼写而互不相同，除此之外这些记号可自由互换。
\end{footnote}
替代记号集合定义于
\tref{lex.digraph}。

\begin{tokentable}{替代记号}{lex.digraph}{替代}{主要}
\tcode{<\%}             &   \tcode{\{}         &
\keyword{and}           &   \tcode{\&\&}       &
\keyword{and_eq}        &   \tcode{\&=}        \\ \rowsep
\tcode{\%>}             &   \tcode{\}}         &
\keyword{bitor}         &   \tcode{|}          &
\keyword{or_eq}         &   \tcode{|=}         \\ \rowsep
\tcode{<:}              &   \tcode{[}          &
\keyword{or}            &   \tcode{||}         &
\keyword{xor_eq}        &   \tcode{\caret=}    \\ \rowsep
\tcode{:>}              &   \tcode{]}          &
\keyword{xor}           &   \tcode{\caret}     &
\keyword{not}           &   \tcode{!}          \\ \rowsep
\tcode{\%:}             &   \tcode{\#}         &
\keyword{compl}         &   \tcode{\~}         &
\keyword{not_eq}        &   \tcode{!=}         \\ \rowsep
\tcode{\%:\%:}          &   \tcode{\#\#}       &
\keyword{bitand}        &   \tcode{\&}         &
                        &                      \\
\end{tokentable}%
\indextext{token!alternative|)}

\rSec1[lex.token]{标记}

\indextext{token|(}%
\begin{bnf}
\nontermdef{token}\br
    identifier\br
    keyword\br
    literal\br
    operator-or-punctuator
\end{bnf}

\pnum
\indextext{\idxgram{token}}%
共有五种标记：标识符、关键字、字面量、%
\begin{footnote}
字面量包括字符串字面量、字符字面量和数值字面量。
\end{footnote}
运算符及其他分隔符。
\indextext{whitespace}%
除用于分隔标记外，注释及字符\unicode{0020}{空格}、\unicode{0009}{水平制表符}、
\unicode{000b}{垂直制表符}、\unicode{000c}{换页符}和换行（统称“空白字符”）均被忽略。
\begin{note}
空白字符可分隔原本相邻的标识符、关键字、数值字面量及含字母字符的替代标记。
\end{note}
\indextext{token|)}

\rSec1[lex.name]{标识符}
\indextext{XID_Start}%
\indextext{XID_Continue}%

\indextext{identifier|(}%
\begin{bnf}
\nontermdef{identifier}\br
    identifier-start\br
    identifier identifier-continue
\end{bnf}

\begin{bnf}
\nontermdef{identifier-start}\br
    nondigit\br
    \textnormal{具有 Unicode 属性 XID_Start 的翻译字符集中的元素}
\end{bnf}

\begin{bnf}
\nontermdef{identifier-continue}\br
    digit\br
    nondigit\br
    \textnormal{具有 Unicode 属性 XID_Continue 的翻译字符集中的元素}
\end{bnf}

\begin{bnf}
\nontermdef{nondigit} \textnormal{为下列之一}\br
    \terminal{a b c d e f g h i j k l m}\br
    \terminal{n o p q r s t u v w x y z}\br
    \terminal{A B C D E F G H I J K L M}\br
    \terminal{N O P Q R S T U V W X Y Z _}
\end{bnf}

\begin{bnf}
\nontermdef{digit} \textnormal{为下列之一}\br
    \terminal{0 1 2 3 4 5 6 7 8 9}
\end{bnf}

\pnum
\indextext{name!length of}%
\indextext{name}%
\begin{note}
字符属性 XID_Start 和 XID_Continue 由 Unicode 标准中的 \UAX{44} 描述。
\begin{footnote}
在链接器无法接受扩展字符的系统中，可以使用 \grammarterm{universal-character-name} 的编码来形成有效的外部标识符。例如，某些未使用的字符或字符序列可用于对 \grammarterm{universal-character-name} 中的 \tcode{\textbackslash u} 进行编码。扩展字符可能会产生较长的外部标识符，但 \Cpp{} 对外部标识符的有效字符数量没有翻译限制。
\end{footnote}
\end{note}
如果 \grammarterm{identifier} 不符合 Unicode 标准中规定的规范化形式 C，则程序非良构。
\begin{note}
标识符区分大小写。
\end{note}
\begin{note}
\ref{uaxid} 比较了 Unicode 标准 \UAX{31} 的要求与 \Cpp{} 标识符规则。
\end{note}
\begin{note}
在翻译阶段 4 中，
\grammarterm{identifier} 也包含
那些在后面的翻译阶段 7\iref{lex.token} 中被区分为关键词\iref{lex.key} 的
\grammarterm{preprocessing-token}\iref{lex.pptoken}。
\end{note}

\pnum
\indextext{\idxcode{import}}%
\indextext{\idxcode{final}}%
\indextext{\idxcode{module}}%
\indextext{\idxcode{override}}%
\indextext{\idxcode{replaceable_if_eligible}}%
\indextext{\idxcode{trivially_relocatable_if_eligible}}%
在特定上下文中出现时，\tref{lex.name.special} 中的标识符具有特殊含义。在语法中引用时，明确使用这些标识符，而不是使用 \grammarterm{identifier} 语法产生式。
除非另有说明，任何关于给定 \grammarterm{identifier} 是否具有特殊含义的歧义，都会被解释为将该记号视为常规的 \grammarterm{identifier}。

\begin{multicolfloattable}{具有特殊含义的标识符}{lex.name.special}
{llll}
\keyword{final}                                 \\
\keyword{override}                              \\\columnbreak
\keyword{import}                                \\
\keyword{module}                                \\\columnbreak
\keyword{post}                                  \\
\keyword{pre}                                   \\\columnbreak
\keyword{replaceable_if_eligible}               \\
\keyword{trivially_relocatable_if_eligible}     \\
\end{multicolfloattable}

\pnum
\indextext{\idxcode{_}|see{character, underscore}}%
\indextext{character!underscore!in identifier}%
\indextext{reserved identifier}%
此外，某些
作为 \grammarterm{token} 或 \grammarterm{preprocessing-token} 出现的标识符
保留供 \Cpp{} 实现使用，不得另作他用；无需诊断。
\begin{itemize}
\item
每个包含双下划线
\tcode{\unun}
\indextext{character!underscore}%
或以下划线开头后跟大写字母的标识符，
除非本文档中特别指明（例如 \xname{cplusplus}\iref{cpp.predefined}），
\indextext{uppercase}%
保留给实现任意使用。
\item
每个以下划线开头的标识符
\indextext{character!underscore}%
保留给实现用作全局名字空间中的名称。%
\indextext{namespace!global}
\end{itemize}%
\indextext{identifier|)}

\rSec1[lex.key]{关键字}

\begin{bnf}
\nontermdef{keyword}\br
    \textnormal{列于\tref{lex.key}中的任意标识符}\br
    \grammarterm{import-keyword}\br
    \grammarterm{module-keyword}\br
    \grammarterm{export-keyword}
\end{bnf}

\pnum
\indextext{keyword|(}%
表\tref{lex.key}所示的标识符保留作关键字（即在第7阶段无条件视为关键字），但出现在\grammarterm{attribute-token}\iref{dcl.attr.grammar}中的除外。
\begin{note}
\keyword{register}关键字目前未使用，但保留供将来使用。
\end{note}

\begin{multicolfloattable}{关键字}{lex.key}
{lllll}
\keyword{alignas} \\
\keyword{alignof} \\
\keyword{asm} \\
\keyword{auto} \\
\keyword{bool} \\
\keyword{break} \\
\keyword{case} \\
\keyword{catch} \\
\keyword{char} \\
\keyword{char8_t} \\
\keyword{char16_t} \\
\keyword{char32_t} \\
\keyword{class} \\
\keyword{concept} \\
\keyword{const} \\
\keyword{consteval} \\
\keyword{constexpr} \\
\columnbreak
\keyword{constinit} \\
\keyword{const_cast} \\
\keyword{continue} \\
\keyword{contract_assert} \\
\keyword{co_await} \\
\keyword{co_return} \\
\keyword{co_yield} \\
\keyword{decltype} \\
\keyword{default} \\
\keyword{delete} \\
\keyword{do} \\
\keyword{double} \\
\keyword{dynamic_cast} \\
\keyword{else} \\
\keyword{enum} \\
\keyword{explicit} \\
\keyword{export} \\
\columnbreak
\keyword{extern} \\
\keyword{false} \\
\keyword{float} \\
\keyword{for} \\
\keyword{friend} \\
\keyword{goto} \\
\keyword{if} \\
\keyword{inline} \\
\keyword{int} \\
\keyword{long} \\
\keyword{mutable} \\
\keyword{namespace} \\
\keyword{new} \\
\keyword{noexcept} \\
\keyword{nullptr} \\
\keyword{operator} \\
\keyword{private} \\
\columnbreak
\keyword{protected} \\
\keyword{public} \\
\keyword{register} \\
\keyword{reinterpret_cast} \\
\keyword{requires} \\
\keyword{return} \\
\keyword{short} \\
\keyword{signed} \\
\keyword{sizeof} \\
\keyword{static} \\
\keyword{static_assert} \\
\keyword{static_cast} \\
\keyword{struct} \\
\keyword{switch} \\
\keyword{template} \\
\keyword{this} \\
\keyword{thread_local} \\
\columnbreak
\keyword{throw} \\
\keyword{true} \\
\keyword{try} \\
\keyword{typedef} \\
\keyword{typeid} \\
\keyword{typename} \\
\keyword{union} \\
\keyword{unsigned} \\
\keyword{using} \\
\keyword{virtual} \\
\keyword{void} \\
\keyword{volatile} \\
\keyword{wchar_t} \\
\keyword{while} \\
\end{multicolfloattable}

\pnum
此外，表\tref{lex.key.digraph}中列出的某些运算符与标点符\iref{lex.digraph}的备选表示形式亦被保留，不得另作他用。

\begin{floattable}{备选表示}{lex.key.digraph}
{llllll}
\topline
\keyword{and}     &   \keyword{and_eq}  &   \keyword{bitand}  &   \keyword{bitor}   &   \keyword{compl}   &   \keyword{not} \\
\keyword{not_eq}  &   \keyword{or}      &   \keyword{or_eq}   &   \keyword{xor}     &   \keyword{xor_eq}  &       \\
\end{floattable}%
\indextext{keyword|)}%

\rSec1[lex.literal]{字面量}%
\indextext{literal|(}

\rSec2[lex.literal.kinds]{字面量的种类}

\pnum
\indextext{constant}%
\indextext{literal!constant}%
存在若干种字面量。
\begin{footnote}
在本文档中，术语“字面量”通常指在 C 中被称为“常量”的那些记号。
\end{footnote}

\begin{bnf}
\nontermdef{literal}\br
    integer-literal\br
    character-literal\br
    floating-point-literal\br
    string-literal\br
    boolean-literal\br
    pointer-literal\br
    user-defined-literal
\end{bnf}
\begin{note}
当以 \grammarterm{expression} 形式出现时，字面量具有类型和值类别\iref{expr.prim.literal}。
\end{note}

\rSec2[lex.icon]{整数字面量}

\indextext{字面量！整数}%
\begin{bnf}
\nontermdef{integer-literal}\br
    binary-literal \opt{integer-suffix}\br
    octal-literal \opt{integer-suffix}\br
    decimal-literal \opt{integer-suffix}\br
    hexadecimal-literal \opt{integer-suffix}
\end{bnf}

\begin{bnf}
\nontermdef{binary-literal}\br
    \terminal{0b} binary-digit\br
    \terminal{0B} binary-digit\br
    binary-literal \opt{\terminal{'}} binary-digit
\end{bnf}

\begin{bnf}
\nontermdef{octal-literal}\br
    \terminal{0}\br
    octal-literal \opt{\terminal{'}} octal-digit
\end{bnf}

\begin{bnf}
\nontermdef{decimal-literal}\br
    nonzero-digit\br
    decimal-literal \opt{\terminal{'}} digit
\end{bnf}

\begin{bnf}
\nontermdef{hexadecimal-literal}\br
    hexadecimal-prefix hexadecimal-digit-sequence
\end{bnf}

\begin{bnf}
\nontermdef{binary-digit} \textnormal{为以下之一}\br
    \terminal{0  1}
\end{bnf}

\begin{bnf}
\nontermdef{octal-digit} \textnormal{为以下之一}\br
    \terminal{0  1  2  3  4  5  6  7}
\end{bnf}

\begin{bnf}
\nontermdef{nonzero-digit} \textnormal{为以下之一}\br
    \terminal{1  2  3  4  5  6  7  8  9}
\end{bnf}

\begin{bnf}
\nontermdef{hexadecimal-prefix} \textnormal{为以下之一}\br
    \terminal{0x  0X}
\end{bnf}

\begin{bnf}
\nontermdef{hexadecimal-digit-sequence}\br
    hexadecimal-digit\br
    hexadecimal-digit-sequence \opt{\terminal{'}} hexadecimal-digit
\end{bnf}

\begin{bnf}
\nontermdef{hexadecimal-digit} \textnormal{为以下之一}\br
    \terminal{0  1  2  3  4  5  6  7  8  9}\br
    \terminal{a  b  c  d  e  f}\br
    \terminal{A  B  C  D  E  F}
\end{bnf}

\begin{bnf}
\nontermdef{integer-suffix}\br
    unsigned-suffix \opt{long-suffix} \br
    unsigned-suffix \opt{long-long-suffix} \br
    unsigned-suffix \opt{size-suffix} \br
    long-suffix \opt{unsigned-suffix} \br
    long-long-suffix \opt{unsigned-suffix} \br
    size-suffix \opt{unsigned-suffix}
\end{bnf}

\begin{bnf}
\nontermdef{unsigned-suffix} \textnormal{为以下之一}\br
    \terminal{u  U}
\end{bnf}

\begin{bnf}
\nontermdef{long-suffix} \textnormal{为以下之一}\br
    \terminal{l  L}
\end{bnf}

\begin{bnf}
\nontermdef{long-long-suffix} \textnormal{为以下之一}\br
    \terminal{ll  LL}
\end{bnf}

\begin{bnf}
\nontermdef{size-suffix} \textnormal{为以下之一}\br
   \terminal{z  Z}
\end{bnf}

\pnum
\indextext{字面量！\idxcode{unsigned}}%
\indextext{字面量！\idxcode{long}}%
\indextext{字面量！整数进制}%
在\grammarterm{integer-literal}中，序列的
\grammarterm{binary-digit}、
\grammarterm{octal-digit}、
\grammarterm{digit}或
\grammarterm{hexadecimal-digit}
被解释为如\tref{lex.icon.base}所示的一个基数为 $N$ 的整数；数字序列中词法上第一个数字是最重要的位。
\begin{note}
在确定数值时，前缀和任何可选的单引号分隔符会被忽略。
\end{note}

\begin{simpletypetable}
{\grammarterm{integer-literal}的进制}
{lex.icon.base}
{lr}
\topline
\lhdr{\grammarterm{integer-literal}的种类} & \rhdr{基数 $N$} \\ \capsep
\grammarterm{binary-literal} & 2 \\
\grammarterm{octal-literal} & 8 \\
\grammarterm{decimal-literal} & 10 \\
\grammarterm{hexadecimal-literal} & 16 \\
\end{simpletypetable}

\pnum
\grammarterm{hexadecimal-digit}
\tcode{a} 到 \tcode{f} 和 \tcode{A} 到 \tcode{F}
对应的十进制值分别为十到十五。
\begin{example}
数字十二可以写作\tcode{12}、\tcode{014}、
\tcode{0XC} 或 \tcode{0b1100}。\grammarterm{integer-literal} \tcode{1048576}、
\tcode{1'048'576}、\tcode{0X100000}、\tcode{0x10'0000} 和
\tcode{0'004'000'000} 都具有相同的值。
\end{example}

\pnum
\indextext{字面量！\idxcode{long}}%
\indextext{字面量！\idxcode{unsigned}}%
\indextext{字面量！整数}%
\indextext{字面量！整数类型}%
\indextext{后缀！\idxcode{L}}%
\indextext{后缀！\idxcode{U}}%
\indextext{后缀！\idxcode{l}}%
\indextext{后缀！\idxcode{u}}%
\grammarterm{integer-literal}的类型
是\tref{lex.icon.type}列表中
对应其可选的\grammarterm{integer-suffix}且能够表示其值的第一个类型。

\begin{floattable}{\grammarterm{integer-literal}的类型}{lex.icon.type}{l|l|l}
\topline
\lhdr{\grammarterm{integer-suffix}} & \chdr{\grammarterm{decimal-literal}}  & \rhdr{除\grammarterm{decimal-literal}之外的\grammarterm{integer-literal}}   \\  \capsep
无    &
  \tcode{int} &
  \tcode{int}\\
        &
  \tcode{long int} &
  \tcode{unsigned int}\\
        &
  \tcode{long long int} &
  \tcode{long int}\\
        &
        &
  \tcode{unsigned long int}\\
        &
        &
  \tcode{long long int}\\
        &
        &
  \tcode{unsigned long long int}\\\hline
\tcode{u} 或 \tcode{U}  &
  \tcode{unsigned int}  &
  \tcode{unsigned int}\\
                              &
  \tcode{unsigned long int}   &
  \tcode{unsigned long int}\\
                              &
  \tcode{unsigned long long int}   &
  \tcode{unsigned long long int}\\\hline
\tcode{l} 或 \tcode{L}  &
  \tcode{long int}  &
  \tcode{long int}\\
                              &
  \tcode{long long int}       &
  \tcode{unsigned long int}\\
                              &
                              &
  \tcode{long long int}\\
                              &
                              &
  \tcode{unsigned long long int}\\\hline
\tcode{u} 或 \tcode{U} 和     &
  \tcode{unsigned long int}  &
  \tcode{unsigned long int}\\
\tcode{l} 或 \tcode{L}          &
  \tcode{unsigned long long int}  &
  \tcode{unsigned long long int}\\\hline
\tcode{ll} 或 \tcode{LL}  &
  \tcode{long long int}       &
  \tcode{long long int}\\
                              &
                              &
  \tcode{unsigned long long int}\\\hline
\tcode{u} 或 \tcode{U} 和      &
  \tcode{unsigned long long int}  &
  \tcode{unsigned long long int}\\
\tcode{ll} 或 \tcode{LL}        &
                              &
                              \\\hline
\tcode{z} 或 \tcode{Z}                 &
  对应于\tcode{std::size_t}\iref{support.types.layout}的 &
  对应于\tcode{std::size_t}的有符号整数类型 \\
                                        &
  有符号整数类型 \qquad  &
  \qquad \\
                                        &
  \tcode{std::size_t} &
  \tcode{std::size_t} \\\hline
\tcode{u} 或 \tcode{U} 和      &
  \tcode{std::size_t}         &
  \tcode{std::size_t}         \\
\tcode{z} 或 \tcode{Z}        &
                              &
                              \\
\end{floattable}

\pnum
对于不包含\grammarterm{size-suffix}的\grammarterm{integer-literal}，
如果\grammarterm{integer-literal}的值不能由其列表中的任何类型表示，
且某个扩展整数类型\iref{basic.fundamental}可以表示其值，则它可以是该扩展整数类型。
如果\grammarterm{integer-literal}列表中的所有类型都是
有符号的，则扩展整数类型是有符号的。
如果\grammarterm{integer-literal}列表中的所有类型都是
无符号的，则扩展整数类型是无符号的。
如果列表中同时包含有符号和无符号类型，
则扩展整数类型可以是有符号或无符号的。
如果\grammarterm{integer-literal}不能由任何允许的类型表示，
则程序是非良构的。
\begin{note}
带有\tcode{z}或\tcode{Z}后缀的\grammarterm{integer-literal}
如果无法用\tcode{std::size_t}表示，则是非良构的。
\end{note}

\rSec2[lex.ccon]{字符字面量}

\indextext{literal!character}%
\begin{bnf}
\nontermdef{character-literal}\br
    \opt{encoding-prefix} \terminal{'} c-char-sequence \terminal{'}
\end{bnf}

\begin{bnf}
\nontermdef{encoding-prefix} \textnormal{其中之一}\br
    \terminal{u8}\quad\terminal{u}\quad\terminal{U}\quad\terminal{L}
\end{bnf}

\begin{bnf}
\nontermdef{c-char-sequence}\br
    c-char \opt{c-char-sequence}
\end{bnf}

\begin{bnf}
\nontermdef{c-char}\br
    basic-c-char\br
    escape-sequence\br
    universal-character-name
\end{bnf}

\begin{bnf}
\nontermdef{basic-c-char}\br
    \textnormal{除\unicode{0027}{撇号}、\unicode{005c}{反斜杠}或换行符外的翻译字符集成员}
\end{bnf}

\begin{bnf}
\nontermdef{escape-sequence}\br
    simple-escape-sequence\br
    numeric-escape-sequence\br
    conditional-escape-sequence
\end{bnf}

\begin{bnf}
\nontermdef{simple-escape-sequence}\br
    \terminal{\textbackslash} simple-escape-sequence-char
\end{bnf}

\begin{bnf}
\nontermdef{simple-escape-sequence-char} \textnormal{其中之一}\br
    \terminal{'  "  ?  \textbackslash{} a  b  f  n  r  t  v}
\end{bnf}

\begin{bnf}
\nontermdef{numeric-escape-sequence}\br
    octal-escape-sequence\br
    hexadecimal-escape-sequence
\end{bnf}

\begin{bnf}
\nontermdef{simple-octal-digit-sequence}\br
    octal-digit \opt{simple-octal-digit-sequence}
\end{bnf}

\begin{bnf}
\nontermdef{octal-escape-sequence}\br
    \terminal{\textbackslash} octal-digit\br
    \terminal{\textbackslash} octal-digit octal-digit\br
    \terminal{\textbackslash} octal-digit octal-digit octal-digit\br
    \terminal{\textbackslash o\{} simple-octal-digit-sequence \terminal{\}}
\end{bnf}

\begin{bnf}
\nontermdef{hexadecimal-escape-sequence}\br
    \terminal{\textbackslash x} simple-hexadecimal-digit-sequence\br
    \terminal{\textbackslash x\{} simple-hexadecimal-digit-sequence \terminal{\}}
\end{bnf}

\begin{bnf}
\nontermdef{conditional-escape-sequence}\br
    \terminal{\textbackslash} conditional-escape-sequence-char
\end{bnf}

\begin{bnf}
\nontermdef{conditional-escape-sequence-char}\br
    \textnormal{基本字符集成员，但非} octal-digit\textnormal{、非} simple-escape-sequence-char\textnormal{、也非\terminal{N}、\terminal{o}、\terminal{u}、\terminal{U}或\terminal{x}}
\end{bnf}

\pnum
\indextext{literal!character}%
\indextext{literal!\idxcode{char8_t}}%
\indextext{literal!\idxcode{char16_t}}%
\indextext{literal!\idxcode{char32_t}}%
\indextext{literal!type of character}%
\indextext{type!\idxcode{char8_t}}%
\indextext{type!\idxcode{char16_t}}%
\indextext{type!\idxcode{char32_t}}%
\indextext{wide-character}%
\indextext{type!\idxcode{wchar_t}}%
\defnadj{多字符}{字面量}是\grammarterm{character-literal}，其\grammarterm{c-char-sequence}包含多于一个\grammarterm{c-char}。
多字符字面量不得有\grammarterm{encoding-prefix}。
若多字符字面量包含的\grammarterm{c-char}在普通字面量编码中无法编码为单个编码单元，则程序非良构。
多字符字面量为条件支持。

\pnum
\grammarterm{character-literal}的种类、类型及其关联字符编码\iref{lex.charset}由\grammarterm{encoding-prefix}和\grammarterm{c-char-sequence}按\tref{lex.ccon.literal}定义确定。

\begin{floattable}{字符字面量}{lex.ccon.literal}
{l|l|l|l|l}
\topline
\lhdr{前缀} & \chdr{种类} & \chdr{类型} & \chdr{关联编码} & \rhdr{示例} \\
\lhdr{} & \chdr{} & \chdr{} & \chdr{} & \\
\capsep
无 &
\defnx{普通字符字面量}{literal!character!ordinary} &
\keyword{char} &
普通字面量编码 &
\tcode{'v'} \\ \cline{2-3}\cline{5-5}
 &
多字符字面量 &
\keyword{int} &
 &
\tcode{'abcd'} \\ \hline
\tcode{L} &
\defnx{宽字符字面量}{literal!character!wide} &
\keyword{wchar_t} &
宽字面量编码 &
\tcode{L'w'} \\
 & & & & \\ \hline
\tcode{u8} &
\defnx{UTF-8字符字面量}{literal!character!UTF-8} &
\keyword{char8_t} &
UTF-8 &
\tcode{u8'x'} \\ \hline
\tcode{u} &
\defnx{UTF-16字符字面量}{literal!character!UTF-16} &
\keyword{char16_t} &
UTF-16 &
\tcode{u'y'} \\ \hline
\tcode{U} &
\defnx{UTF-32字符字面量}{literal!character!UTF-32} &
\keyword{char32_t} &
UTF-32 &
\tcode{U'z'} \\
\end{floattable}

\pnum
在翻译阶段4，\grammarterm{character-literal}的值使用其类型在翻译阶段7的可表示值范围确定。
多字符字面量的值由实现定义。
其他\grammarterm{character-literal}的值按下列规则确定：
\begin{itemize}
\item
\grammarterm{c-char-sequence}由单个\grammarterm{basic-c-char}、\grammarterm{simple-escape-sequence}或\grammarterm{universal-character-name}组成的\grammarterm{character-literal}的值为指定字符在该字面量关联字符编码中的编码单元值。
若指定字符在关联编码中无表示或无法编码为单个编码单元，则程序非良构。
\item
\grammarterm{c-char-sequence}由单个\grammarterm{numeric-escape-sequence}组成的\grammarterm{character-literal}的值按如下确定：
\begin{itemize}
\item
令$v$为\grammarterm{octal-escape-sequence}的\grammarterm{octal-digit}序列组成的八进制数或\grammarterm{hexadecimal-escape-sequence}的\grammarterm{hexadecimal-digit}序列组成的十六进制数表示的整数值。
\item
若$v$不超过该字面量类型的可表示值范围，则值为$v$。
\item
否则，若该字面量无\grammarterm{encoding-prefix}或为\tcode{L}，且$v$不超过该类型对应无符号类型的可表示值范围，则值为该类型\tcode{T}与$v$模$2^N$同余的唯一值，其中$N$为\tcode{T}的宽度。
\item
否则程序非良构。
\end{itemize}
\item
\grammarterm{c-char-sequence}由单个\grammarterm{conditional-escape-sequence}组成的\grammarterm{character-literal}为条件支持，其值由实现定义。
\end{itemize}

\pnum
\indextext{backslash character}%
\indextext{\idxcode{\textbackslash}|see{backslash character}}%
\indextext{escape character|see{backslash character}}%
\grammarterm{simple-escape-sequence}指定的字符见\tref{lex.ccon.esc}。
\begin{note}
为兼容\CppXIV{}和C，支持用转义序列表示问号。
\end{note}

\begin{floattable}{简单转义序列}{lex.ccon.esc}
{lll}
\topline
\lhdrx{2}{字符} &  \rhdr{\grammarterm{simple-escape-sequence}} \\ \capsep
\ucode{000a} & \uname{换行}            & \tcode{\textbackslash n} \\
\ucode{0009} & \uname{水平制表} & \tcode{\textbackslash t} \\
\ucode{000b} & \uname{垂直制表}      & \tcode{\textbackslash v} \\
\ucode{0008} & \uname{退格}            & \tcode{\textbackslash b} \\
\ucode{000d} & \uname{回车}      & \tcode{\textbackslash r} \\
\ucode{000c} & \uname{换页}            & \tcode{\textbackslash f} \\
\ucode{0007} & \uname{响铃}                & \tcode{\textbackslash a} \\
\ucode{005c} & \uname{反斜杠}      & \tcode{\textbackslash\textbackslash} \\
\ucode{003f} & \uname{问号}        & \tcode{\textbackslash ?} \\
\ucode{0027} & \uname{撇号}           & \tcode{\textbackslash '} \\
\ucode{0022} & \uname{引号}       & \tcode{\textbackslash "} \\
\end{floattable}

\rSec2[lex.fcon]{浮点数字面值}

\indextext{literal!floating-point}%
\begin{bnf}
\nontermdef{floating-point-literal}\br
    decimal-floating-point-literal\br
    hexadecimal-floating-point-literal
\end{bnf}

\begin{bnf}
\nontermdef{decimal-floating-point-literal}\br
    fractional-constant \opt{exponent-part} \opt{floating-point-suffix}\br
    digit-sequence exponent-part \opt{floating-point-suffix}
\end{bnf}

\begin{bnf}
\nontermdef{hexadecimal-floating-point-literal}\br
    hexadecimal-prefix hexadecimal-fractional-constant binary-exponent-part \opt{floating-point-suffix}\br
    hexadecimal-prefix hexadecimal-digit-sequence binary-exponent-part \opt{floating-point-suffix}
\end{bnf}

\begin{bnf}
\nontermdef{fractional-constant}\br
    \opt{digit-sequence} \terminal{.} digit-sequence\br
    digit-sequence \terminal{.}
\end{bnf}

\begin{bnf}
\nontermdef{hexadecimal-fractional-constant}\br
    \opt{hexadecimal-digit-sequence} \terminal{.} hexadecimal-digit-sequence\br
    hexadecimal-digit-sequence \terminal{.}
\end{bnf}

\begin{bnf}
\nontermdef{exponent-part}\br
    \terminal{e} \opt{sign} digit-sequence\br
    \terminal{E} \opt{sign} digit-sequence
\end{bnf}

\begin{bnf}
\nontermdef{binary-exponent-part}\br
    \terminal{p} \opt{sign} digit-sequence\br
    \terminal{P} \opt{sign} digit-sequence
\end{bnf}

\begin{bnf}
\nontermdef{sign} \textnormal{其中之一}\br
    \terminal{+  -}
\end{bnf}

\begin{bnf}
\nontermdef{digit-sequence}\br
    digit\br
    digit-sequence \opt{\terminal{'}} digit
\end{bnf}

\begin{bnf}
\nontermdef{floating-point-suffix} \textnormal{其中之一}\br
    \terminal{f  l  f16  f32  f64  f128  bf16  F  L  F16  F32  F64  F128  BF16}
\end{bnf}

\pnum
\indextext{literal!type of floating-point}%
\indextext{literal!\idxcode{float}}%
\indextext{suffix!\idxcode{F}}%
\indextext{suffix!\idxcode{f}}%
\indextext{suffix!\idxcode{L}}%
\indextext{suffix!\idxcode{l}}%
\indextext{literal!\idxcode{long double}}%
\grammarterm{floating-point-literal}\iref{basic.fundamental,basic.extended.fp}的类型
取决于其\grammarterm{floating-point-suffix}，如\tref{lex.fcon.type}所指定。
\begin{note}
浮点后缀
\tcode{f16}、\tcode{f32}、\tcode{f64}、\tcode{f128}、\tcode{bf16}、
\tcode{F16}、\tcode{F32}、\tcode{F64}、\tcode{F128} 和 \tcode{BF16}
是有条件支持的。参见 \ref{basic.extended.fp}。
\end{note}
\begin{simpletypetable}
{\grammarterm{floating-point-literal}的类型}
{lex.fcon.type}
{ll}
\topline
\lhdr{\grammarterm{floating-point-suffix}} & \rhdr{type} \\ \capsep
无 & \keyword{double} \\
\tcode{f} 或 \tcode{F} & \keyword{float} \\
\tcode{l} 或 \tcode{L} & \keyword{long} \keyword{double} \\
\tcode{f16} 或 \tcode{F16} & \tcode{std::float16_t} \\
\tcode{f32} 或 \tcode{F32} & \tcode{std::float32_t} \\
\tcode{f64} 或 \tcode{F64} & \tcode{std::float64_t} \\
\tcode{f128} 或 \tcode{F128} & \tcode{std::float128_t} \\
\tcode{bf16} 或 \tcode{BF16} & \tcode{std::bfloat16_t} \\
\end{simpletypetable}

\pnum
\indextext{literal!floating-point}%
\grammarterm{floating-point-literal}的\defn{有效数}是指：
对于\grammarterm{decimal-floating-point-literal}，为其\grammarterm{fractional-constant}或\grammarterm{digit-sequence}；
对于\grammarterm{hexadecimal-floating-point-literal}，为其\grammarterm{hexadecimal-fractional-constant}或\grammarterm{hexadecimal-digit-sequence}。
在有效数中，\grammarterm{digit}序列或\grammarterm{hexadecimal-digit}序列以及可选的小数点，被解释为一个基数为$N$的实数$s$，
其中对于\grammarterm{decimal-floating-point-literal} $N$为10，对于\grammarterm{hexadecimal-floating-point-literal} $N$为16。
\begin{note}
确定数值时任何可选的分隔单引号都会被忽略。
\end{note}
如果存在\grammarterm{exponent-part}或\grammarterm{binary-exponent-part}，
那么\grammarterm{floating-point-literal}的指数$e$即为将可选\grammarterm{sign}和\grammarterm{digit}序列解释为一个十进制整数所得的结果。
否则，指数$e$为0。
该字面值的缩放值为：
对于\grammarterm{decimal-floating-point-literal}是$s \times 10^e$；
对于\grammarterm{hexadecimal-floating-point-literal}是$s \times 2^e$。
\begin{example}
\grammarterm{floating-point-literal}
\tcode{49.625} 和 \tcode{0xC.68p+2} 具有相同的值。
\grammarterm{floating-point-literal}
\tcode{1.602'176'565e-19} 和 \tcode{1.602176565e-19}
具有相同的值。
\end{example}

\pnum
如果缩放值不在其类型的可表示值范围内，则程序非良构。
否则，\grammarterm{floating-point-literal}的值是：若缩放值可表示，则为缩放值；
否则为最接近缩放值的较大或较小的可表示值，具体选择方式由\impldef{choice of larger or smaller value of
\grammarterm{floating-point-literal}}规定。

\rSec2[lex.string]{字符串字面量}

\indextext{literal!string}%
\begin{bnf}
\nontermdef{string-literal}\br
    \opt{encoding-prefix} \terminal{"} \opt{s-char-sequence} \terminal{"}\br
    \opt{encoding-prefix} \terminal{R} raw-string
\end{bnf}

\begin{bnf}
\nontermdef{s-char-sequence}\br
    s-char \opt{s-char-sequence}
\end{bnf}

\begin{bnf}
\nontermdef{s-char}\br
    basic-s-char\br
    escape-sequence\br
    universal-character-name
\end{bnf}

\begin{bnf}
\nontermdef{basic-s-char}\br
    \textnormal{翻译字符集中除 \unicode{0022}{双引号}、}\br
    \bnfindent\textnormal{\unicode{005c}{反斜杠}或换行符以外的任意成员}
\end{bnf}

\begin{bnf}
\nontermdef{raw-string}\br
    \terminal{"} \opt{d-char-sequence} \terminal{(} \opt{r-char-sequence} \terminal{)} \opt{d-char-sequence} \terminal{"}
\end{bnf}

\begin{bnf}
\nontermdef{r-char-sequence}\br
    r-char \opt{r-char-sequence}
\end{bnf}

\begin{bnf}
\nontermdef{r-char}\br
    \textnormal{翻译字符集中除一个 \unicode{0029}{右圆括号}紧接其后为}\br
    \bnfindent\textnormal{初始 \grammarterm{d-char-sequence}（可能为空）再紧接 \unicode{0022}{双引号}以外的任意成员}
\end{bnf}

\begin{bnf}
\nontermdef{d-char-sequence}\br
    d-char \opt{d-char-sequence}
\end{bnf}

\begin{bnf}
\nontermdef{d-char}\br
    \textnormal{基本字符集中除以下字符外的任意成员：}\br
    \bnfindent\textnormal{\unicode{0020}{空格}、\unicode{0028}{左圆括号}、\unicode{0029}{右圆括号}、\unicode{005c}{反斜杠}、}\br
    \bnfindent\textnormal{\unicode{0009}{字符制表符}、\unicode{000b}{行制表符}、\unicode{000c}{换页符}及换行符}
\end{bnf}

\pnum
\indextext{literal!string}%
\indextext{character string}%
\indextext{string!type of}%
\indextext{type!\idxcode{wchar_t}}%
\indextext{prefix!\idxcode{L}}%
\indextext{literal!string!\idxcode{char16_t}}%
\indextext{type!\idxcode{char16_t}}%
\indextext{literal!string!\idxcode{char32_t}}%
\indextext{type!\idxcode{char32_t}}%
一个 \grammarterm{string-literal} 的类别、
其类型及其关联字符编码\iref{lex.charset}
由其编码前缀及 \grammarterm{s-char} 或 \grammarterm{r-char} 序列决定，
如 \tref{lex.string.literal} 所定义，其中 $n$ 为对该 \grammarterm{string-literal} 求值后产生的编码代码单元数（见下文）。

\begin{floattable}{字符串字面量}{lex.string.literal}
{llp{2.6cm}p{2.3cm}p{4.7cm}}
\topline
\lhdr{编码} & \chdr{类别} & \chdr{类型} & \chdr{关联} & \rhdr{示例} \\
\lhdr{前缀}   & \chdr{} & \chdr{} & \chdr{字符编码}  & \rhdr{} \\
\lhdr{}         & \chdr{} & \chdr{} & \chdr{}   & \rhdr{} \\
\capsep
无 &
\defnx{普通字符串字面量}{literal!string!ordinary} &
包含 $n$ 个 \tcode{\keyword{const} \keyword{char}} 的数组 &
普通字面量编码 &
\tcode{"ordinary string"}\newline
\tcode{R"(ordinary raw string)"} \\
\tcode{L} &
\defnx{宽字符串字面量}{literal!string!wide} &
包含 $n$ 个 \tcode{\keyword{const} \keyword{wchar_t}} 的数组 &
宽字面量\newline 编码 &
\tcode{L"wide string"}\newline
\tcode{LR"w(wide raw string)w"} \\
\tcode{u8} &
\defnx{UTF-8 字符串字面量}{literal!string!UTF-8} &
包含 $n$ 个 \tcode{\keyword{const} \keyword{char8_t}} 的数组 &
UTF-8 &
\tcode{u8"UTF-8 string"}\newline
\tcode{u8R"x(UTF-8 raw string)x"} \\
\tcode{u} &
\defnx{UTF-16 字符串字面量}{literal!string!UTF-16} &
包含 $n$ 个 \tcode{\keyword{const} \keyword{char16_t}} 的数组 &
UTF-16 &
\tcode{u"UTF-16 string"}\newline
\tcode{uR"y(UTF-16 raw string)y"} \\
\tcode{U} &
\defnx{UTF-32 字符串字面量}{literal!string!UTF-32} &
包含 $n$ 个 \tcode{\keyword{const} \keyword{char32_t}} 的数组 &
UTF-32 &
\tcode{U"UTF-32 string"}\newline
\tcode{UR"z(UTF-32 raw string)z"} \\
\end{floattable}

\pnum
\indextext{literal!string!raw}%
前缀中包含 \tcode{R} 的 \grammarterm{string-literal} 为 \defn{原始字符串字面量}。
\indextext{prefix!\idxcode{R}}%
\grammarterm{d-char-sequence} 用作分隔符。某个 \grammarterm{raw-string} 的终止 \grammarterm{d-char-sequence} 与初始 \grammarterm{d-char-sequence} 为同一字符序列。\grammarterm{d-char-sequence} 至多包含 16 个字符。

\pnum
\begin{note}
字符 \tcode{'('} 和 \tcode{')'} 可出现在 \grammarterm{raw-string} 中。因此，\tcode{R"delimiter((a|b))delimiter"} 等价于 \tcode{"(a|b)"}。
\end{note}

\pnum
\begin{note}
原始字符串字面量中的源文件换行会导致结果执行字符串字面量中出现换行。假设下例各行开头无空白，则断言成立：
\begin{codeblock}
const char* p = R"(a\
b
c)";
assert(std::strcmp(p, "a\\\nb\nc") == 0);
\end{codeblock}
\end{note}

\pnum
\begin{example}
原始字符串
\begin{codeblock}
R"a(
)\
a"
)a"
\end{codeblock}
等价于 \tcode{"\textbackslash n)\textbackslash \textbackslash \textbackslash na\textbackslash"\textbackslash n"}。原始字符串
\begin{codeblock}
R"(x = "\"y\"")"
\end{codeblock}
等价于 \tcode{"x = \textbackslash "\textbackslash\textbackslash\textbackslash "y\textbackslash\textbackslash\textbackslash "\textbackslash ""}。
\end{example}

\pnum
\indextext{literal!narrow-character}%
普通字符串字面量和 UTF-8 字符串字面量亦称为 \defnx{窄字符串字面量}{literal!string!narrow}。

\pnum
\indextext{concatenation!string}%
在任何相邻 \grammarterm{string-literal} 组成的序列中，至多有一个唯一的 \grammarterm{encoding-prefix}。该序列的公共 \grammarterm{encoding-prefix} 即为该前缀（如有）。
\begin{note}
\grammarterm{string-literal} 的原始性不影响公共 \grammarterm{encoding-prefix} 的确定。
\end{note}

\pnum
在翻译阶段 6\iref{lex.phases}，相邻 \grammarterm{string-literal} 被拼接。各 \grammarterm{string-literal} 内容的词法结构与分组保持不变。
\begin{example}
\begin{codeblock}
"\xA" "B"
\end{codeblock}
拼接后表示代码单元 \tcode{'\textbackslash xA'} 和字符 \tcode{'B'}
（而非单个代码单元 \tcode{'\textbackslash xAB'}）。
同样，
\begin{codeblock}
R"(\u00)" "41"
\end{codeblock}
表示六个字符，以反斜杠开头并以数字 \tcode{1} 结尾
（而非由 \grammarterm{universal-character-name} 指定的单个字符 \tcode{'A'}）。

\tref{lex.string.concat} 给出了一些有效拼接示例。
\end{example}

\begin{floattable}{字符串字面量拼接}{lex.string.concat}
{lll|lll|lll}
\topline
\multicolumn{2}{|c}{源码} &
含义 &
\multicolumn{2}{c}{源码} &
含义 &
\multicolumn{2}{c}{源码} &
含义 \\
\tcode{u"a"} & \tcode{u"b"} & \tcode{u"ab"} &
\tcode{U"a"} & \tcode{U"b"} & \tcode{U"ab"} &
\tcode{L"a"} & \tcode{L"b"} & \tcode{L"ab"} \\
\tcode{u"a"} & \tcode{"b"}  & \tcode{u"ab"} &
\tcode{U"a"} & \tcode{"b"}  & \tcode{U"ab"} &
\tcode{L"a"} & \tcode{"b"}  & \tcode{L"ab"} \\
\tcode{"a"}  & \tcode{u"b"} & \tcode{u"ab"} &
\tcode{"a"}  & \tcode{U"b"} & \tcode{U"ab"} &
\tcode{"a"}  & \tcode{L"b"} & \tcode{L"ab"} \\
\end{floattable}

\pnum
对 \grammarterm{string-literal} 求值产生一个具有静态存储期\iref{basic.stc} 的字符串字面量对象。
\begin{note}
字符串字面量对象可能不唯一\iref{intro.object}。同一 \grammarterm{string-literal} 连续求值得到相同或不同对象由实现定义。
\end{note}
\begin{note}
\indextext{literal!string!undefined change to}%
试图修改字符串字面量对象的效果是未定义的。
\end{note}

\pnum
\indextext{\idxcode{0}!string terminator}%
\indextext{\idxcode{0}!null character|see {character, null}}%
字符串字面量对象按以下顺序使用对应于该 \grammarterm{string-literal} 的 \grammarterm{s-char} 序列（最初来自非原始字符串字面量）和 \grammarterm{r-char} 序列（最初来自原始字符串字面量）的代码单元值序列，再加上一个终止 \unicode{0000}{空字符}进行初始化：
\begin{itemize}
\item
每个连续 \grammarterm{basic-s-char} 序列、
\grammarterm{r-char} 序列、
\grammarterm{simple-escape-sequence}\iref{lex.ccon} 和
\grammarterm{universal-character-name}\iref{lex.charset}
所表示的字符序列，使用该 \grammarterm{string-literal} 的关联字符编码编码为代码单元序列。
若某字符在关联字符编码中无表示，则程序为 ill-formed。
\begin{note}
任何 Unicode 编码形式中均不存在无表示的字符。
\end{note}
对有状态字符编码进行编码时，实现应对第一个这样的序列从初始编码状态开始编码，并对后续序列从前一序列的最终编码状态开始编码。
\begin{note}
编码后的代码单元序列可能与独立编码每个字符得到的代码单元序列不同。
\end{note}
\item
每个 \grammarterm{numeric-escape-sequence}\iref{lex.ccon} 贡献一个代码单元，其值如下：
\begin{itemize}
\item
令 $v$ 为由八进制转义序列中 \grammarterm{octal-digit} 序列构成的八进制数所表示的整数值，或由十六进制转义序列中 \grammarterm{hexadecimal-digit} 序列构成的十六进制数所表示的整数值。
\item
若 $v$ 未超出该 \grammarterm{string-literal} 数组元素类型可表示值范围，则值为 $v$。
\item
否则，若该 \grammarterm{string-literal} 的 \grammarterm{encoding-prefix} 不存在或为 \tcode{L}，且 $v$ 未超出该 \grammarterm{string-literal} 数组元素类型对应底层类型的无符号类型可表示值范围，则值为与该 \grammarterm{string-literal} 数组元素类型 \tcode{T} 模 $2^N$ 同余的唯一值，其中 $N$ 为 \tcode{T} 的宽度。
\item
否则，程序为 ill-formed。
\end{itemize}
对有状态字符编码进行编码时，这些序列应对编码状态无影响。
\item
每个 \grammarterm{conditional-escape-sequence}\iref{lex.ccon} 贡献一个
\impldef{code unit sequence for \grammarterm{conditional-escape-sequence}} 的代码单元序列。
对有状态字符编码进行编码时，这些序列对编码状态的影响由
\impldef{effect of \grammarterm{conditional-escape-sequence} on encoding state} 决定。
\end{itemize}

\rSec2[lex.string.uneval]{不求值字符串}

\begin{bnf}
\nontermdef{unevaluated-string}\br
    string-literal
\end{bnf}

\pnum
\grammarterm{unevaluated-string} 不得具有 \grammarterm{encoding-prefix}。

\pnum
\grammarterm{unevaluated-string} 中的每个 \grammarterm{universal-character-name} 和每个 \grammarterm{simple-escape-sequence}
均被替换为它所表示的翻译字符集成员。
含有 \grammarterm{numeric-escape-sequence} 或
\grammarterm{conditional-escape-sequence}
的 \grammarterm{unevaluated-string} 为非法。

\pnum
\grammarterm{unevaluated-string} 永不被求值，
其解释取决于出现的上下文。

\rSec2[lex.bool]{布尔字面量}

\indextext{literal!boolean}%
\begin{bnf}
\nontermdef{boolean-literal}\br
    \keyword{false}\br
    \keyword{true}
\end{bnf}

\pnum
\indextext{Boolean literal}%
布尔字面量是关键字\tcode{false}和\tcode{true}。
这类字面量具有类型\tcode{bool}。

\rSec2[lex.nullptr]{指针字面量}

\indextext{literal!指针}%
\begin{bnf}
\nontermdef{pointer-literal}\br
    \keyword{nullptr}
\end{bnf}

\pnum
指针字面量是关键词 \keyword{nullptr}。它的类型为 \tcode{std::nullptr_t}。
\begin{note}
\tcode{std::nullptr_t} 是一种独特类型，既不是指针类型也不是指针到成员类型；
确切地说，此类型的纯右值是一个空指针常量，并且可以转换为空指针值或空成员指针值。参见 \ref{conv.ptr} 和 \ref{conv.mem}。
\end{note}

\rSec2[lex.ext]{用户定义字面量}

\indextext{literal!user-defined}%
\begin{bnf}
\nontermdef{user-defined-literal}\br
    user-defined-integer-literal\br
    user-defined-floating-point-literal\br
    user-defined-string-literal\br
    user-defined-character-literal
\end{bnf}

\begin{bnf}
\nontermdef{user-defined-integer-literal}\br
    decimal-literal ud-suffix\br
    octal-literal ud-suffix\br
    hexadecimal-literal ud-suffix\br
    binary-literal ud-suffix
\end{bnf}

\begin{bnf}
\nontermdef{user-defined-floating-point-literal}\br
    fractional-constant \opt{exponent-part} ud-suffix\br
    digit-sequence exponent-part ud-suffix\br
    hexadecimal-prefix hexadecimal-fractional-constant binary-exponent-part ud-suffix\br
    hexadecimal-prefix hexadecimal-digit-sequence binary-exponent-part ud-suffix
\end{bnf}

\begin{bnf}
\nontermdef{user-defined-string-literal}\br
    string-literal ud-suffix
\end{bnf}

\begin{bnf}
\nontermdef{user-defined-character-literal}\br
    character-literal ud-suffix
\end{bnf}

\begin{bnf}
\nontermdef{ud-suffix}\br
    identifier
\end{bnf}

\pnum
如果一个单词既匹配 \grammarterm{user-defined-literal} 又匹配其他 \grammarterm{literal} 种类，则它被视为后者。
\begin{example}
\tcode{123_km} 是 \grammarterm{user-defined-literal}，但 \tcode{12LL} 是
\grammarterm{integer-literal}。
\end{example}
在 \grammarterm{user-defined-literal} 中，\grammarterm{ud-suffix} 之前的语法非终结符被认为是能够匹配该非终结符的最长字符序列。

\pnum
\grammarterm{user-defined-literal} 被视为对字面量运算符或字面量运算符模板的调用\iref{over.literal}。
为了确定具有 \grammarterm{ud-suffix} \placeholder{X} 的给定 \grammarterm{user-defined-literal} \placeholder{L} 的此调用的形式，
首先令 \placeholder{S} 为通过非限定查找找到的、
其字面量后缀标识符为 \placeholder{X} 的 \grammarterm{literal-operator-id}\iref{basic.lookup.unqual} 的声明集。
\placeholder{S} 不得为空。

\pnum
如果 \placeholder{L} 是 \grammarterm{user-defined-integer-literal}，令 \placeholder{n} 为不带其 \grammarterm{ud-suffix} 的字面量。
如果 \placeholder{S} 包含参数类型为 \tcode{unsigned long long} 的字面量运算符，
则字面量 \placeholder{L} 被视为形如的调用：
\begin{codeblock}
operator ""@\placeholder{X}@(@\placeholder{n}@ULL)
\end{codeblock}
否则，\placeholder{S} 应包含原始字面量运算符或数值字面量运算符模板\iref{over.literal}，但不得同时包含两者。
如果 \placeholder{S} 包含原始字面量运算符，
则字面量 \placeholder{L} 被视为形如的调用：
\begin{codeblock}
operator ""@\placeholder{X}@("@\placeholder{n}@")
\end{codeblock}
否则（\placeholder{S} 包含数值字面量运算符模板），
\placeholder{L} 被视为形如的调用：
\begin{codeblock}
operator ""@\placeholder{X}@<'@$c_1$@', '@$c_2$@', ... '@$c_k$@'>()
\end{codeblock}
其中 \placeholder{n} 是源字符序列 $c_1c_2...c_k$。
\begin{note}
序列
$c_1c_2...c_k$ 只能包含基本字符集中的字符。
\end{note}

\pnum
如果 \placeholder{L} 是 \grammarterm{user-defined-floating-point-literal}，令 \placeholder{f} 为
不带其 \grammarterm{ud-suffix} 的字面量。
如果 \placeholder{S} 包含参数类型为 \tcode{long double} 的字面量运算符，
则字面量 \placeholder{L} 被视为形如的调用：
\begin{codeblock}
operator ""@\placeholder{X}@(@\placeholder{f}@L)
\end{codeblock}
否则，\placeholder{S} 应包含原始字面量运算符或数值字面量运算符模板\iref{over.literal}，但不得同时包含两者。
如果 \placeholder{S} 包含原始字面量运算符，
则 \grammarterm{literal} \placeholder{L} 被视为形如的调用：
\begin{codeblock}
operator ""@\placeholder{X}@("@\placeholder{f}@")
\end{codeblock}
否则（\placeholder{S} 包含数值字面量运算符模板），
\placeholder{L} 被视为形如的调用：
\begin{codeblock}
operator ""@\placeholder{X}@<'@$c_1$@', '@$c_2$@', ... '@$c_k$@'>()
\end{codeblock}
其中 \placeholder{f} 是源字符序列 $c_1c_2...c_k$。
\begin{note}
序列
$c_1c_2...c_k$ 只能包含基本字符集中的字符。
\end{note}

\pnum
如果 \placeholder{L} 是 \grammarterm{user-defined-string-literal}，
令 \placeholder{str} 为不带其 \grammarterm{ud-suffix} 的字面量，
并令 \placeholder{len} 为 \placeholder{str} 中的码单元数
（即不包括终止空字符的长度）。
如果 \placeholder{S} 包含一个字面量运算符模板，其具有一个常量模板参数，
且 \placeholder{str} 是该参数的良构 \grammarterm{template-argument}，
则字面量 \placeholder{L} 被视为形如的调用：
\begin{codeblock}
operator ""@\placeholder{X}@<@\placeholder{str}{}@>()
\end{codeblock}
否则，字面量 \placeholder{L} 被视为形如的调用：
\begin{codeblock}
operator ""@\placeholder{X}@(@\placeholder{str}{}@, @\placeholder{len}{}@)
\end{codeblock}

\pnum
如果 \placeholder{L} 是 \grammarterm{user-defined-character-literal}，令 \placeholder{ch} 为
不带其 \grammarterm{ud-suffix} 的字面量。
\placeholder{S} 应包含一个字面量运算符\iref{over.literal}，
其唯一参数具有 \placeholder{ch} 的类型，
并且字面量 \placeholder{L} 被视为形如的调用：
\begin{codeblock}
operator ""@\placeholder{X}@(@\placeholder{ch}{}@)
\end{codeblock}

\pnum
\begin{example}
\begin{codeblock}
long double operator ""_w(long double);
std::string operator ""_w(const char16_t*, std::size_t);
unsigned operator ""_w(const char*);
int main() {
  1.2_w;            // 调用 \tcode{operator ""_w(1.2L)}
  u"one"_w;         // 调用 \tcode{operator ""_w(u"one", 3)}
  12_w;             // 调用 \tcode{operator ""_w("12")}
  "two"_w;          // 错误：无适用的字面量运算符
}
\end{codeblock}
\end{example}

\pnum
在翻译阶段 6\iref{lex.phases}，相邻的 \grammarterm{string-literal} 会被连接，并且
为此目的，\grammarterm{user-defined-string-literal}{s} 被视为 \grammarterm{string-literal}。
在连接过程中，\grammarterm{ud-suffix}{es} 被移除并忽略，
连接过程按照\ref{lex.string}中的描述进行。
在阶段 6 结束时，如果一个 \grammarterm{string-literal} 是涉及至少一个
\grammarterm{user-defined-string-literal} 的连接结果，则所有参与的
\grammarterm{user-defined-string-literal}{s} 应具有相同的 \grammarterm{ud-suffix}，
并且该后缀将应用于连接结果。

\pnum
\begin{example}
\begin{codeblock}
int main() {
  L"A" "B" "C"_x;   // OK，等同于 \tcode{L"ABC"_x}
  "P"_x "Q" "R"_y;  // 错误：两个不同的 \grammarterm{ud-suffix}{es}
}
\end{codeblock}
\end{example}
\indextext{literal|)}%
\indextext{conventions!lexical|)}

